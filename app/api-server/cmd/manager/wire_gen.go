// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"github.com/go-kratos/kratos/v2"
	"github.com/go-kratos/kratos/v2/log"
	"github.com/nautes-labs/nautes/app/api-server/internal/biz"
	"github.com/nautes-labs/nautes/app/api-server/internal/conf"
	"github.com/nautes-labs/nautes/app/api-server/internal/data"
	"github.com/nautes-labs/nautes/app/api-server/internal/server"
	"github.com/nautes-labs/nautes/app/api-server/internal/service"
	"github.com/nautes-labs/nautes/app/api-server/pkg/clusters"
	"github.com/nautes-labs/nautes/app/api-server/pkg/nodestree"
	"github.com/nautes-labs/nautes/pkg/nautesconfigs"
	"github.com/nautes-labs/nautes/pkg/queue"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

import (
	_ "net/http/pprof"
)

// Injectors from wire.go:

// wireApp init kratos application.
func wireApp(confServer *conf.Server, logger log.Logger, nodesTree nodestree.NodesTree, config *configs.Config, client2 client.Client, clusteroperator cluster.ClusterRegistrationOperator, q queue.Queuer) (*kratos.App, func(), error) {
	codeRepo, err := data.NewCodeRepo(config)
	if err != nil {
		return nil, nil, err
	}
	secretrepo, err := data.NewSecretRepo(config)
	if err != nil {
		return nil, nil, err
	}
	gitRepo, err := data.NewGitRepo(config)
	if err != nil {
		return nil, nil, err
	}
	resourcesUsecase := biz.NewResourcesUsecase(logger, codeRepo, secretrepo, gitRepo, nodesTree, config)
	codeRepoBindingUsecase := biz.NewCodeRepoCodeRepoBindingUsecase(logger, codeRepo, secretrepo, nodesTree, resourcesUsecase, config, client2)
	codeRepoUsecase := biz.NewCodeRepoUsecase(logger, codeRepo, secretrepo, nodesTree, config, resourcesUsecase, codeRepoBindingUsecase, client2)
	productUsecase := biz.NewProductUsecase(logger, codeRepo, secretrepo, gitRepo, config, resourcesUsecase, codeRepoUsecase)
	productService := service.NewProductService(productUsecase, config)
	grpcServer := server.NewGRPCServer(confServer, productService, logger)
	projectPipelineRuntimeUsecase := biz.NewProjectPipelineRuntimeUsecase(logger, codeRepo, nodesTree, resourcesUsecase, client2, config)
	projectPipelineRuntimeService := service.NewProjectPipelineRuntimeService(projectPipelineRuntimeUsecase, resourcesUsecase)
	deploymentRuntimeUsecase := biz.NewDeploymentRuntimeUsecase(logger, codeRepo, nodesTree, resourcesUsecase, client2, config)
	deploymentruntimeService := service.NewDeploymentruntimeService(deploymentRuntimeUsecase, resourcesUsecase)
	codeRepoService := service.NewCodeRepoService(codeRepoUsecase, config)
	codeRepoBindingService := service.NewCodeRepoBindingService(codeRepoBindingUsecase, resourcesUsecase)
	projectUsecase := biz.NewProjectUsecase(logger, codeRepo, secretrepo, nodesTree, config, resourcesUsecase)
	projectService := service.NewProjectService(projectUsecase)
	environmentUsecase := biz.NewEnviromentUsecase(logger, config, codeRepo, nodesTree, resourcesUsecase)
	environmentService := service.NewEnvironmentService(environmentUsecase)
	clusterUsecase := biz.NewClusterUsecase(logger, codeRepo, secretrepo, resourcesUsecase, config, client2, clusteroperator, q)
	clusterService, err := service.NewClusterService(clusterUsecase, config)
	if err != nil {
		return nil, nil, err
	}
	serviceProductGroup := server.NewServiceGroup(projectPipelineRuntimeService, deploymentruntimeService, codeRepoService, codeRepoBindingService, productService, projectService, environmentService, clusterService)
	httpServer := server.NewHTTPServer(confServer, serviceProductGroup)
	app := newApp(logger, grpcServer, httpServer)
	return app, func() {
	}, nil
}
