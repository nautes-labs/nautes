// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/gitlab/interface.go

// Package gitlab is a generated GoMock package.
package gitlab

import (
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	go_gitlab "github.com/xanzy/go-gitlab"
)

// MockGitlabOperator is a mock of GitlabOperator interface.
type MockGitlabOperator struct {
	ctrl     *gomock.Controller
	recorder *MockGitlabOperatorMockRecorder
}

// MockGitlabOperatorMockRecorder is the mock recorder for MockGitlabOperator.
type MockGitlabOperatorMockRecorder struct {
	mock *MockGitlabOperator
}

// NewMockGitlabOperator creates a new mock instance.
func NewMockGitlabOperator(ctrl *gomock.Controller) *MockGitlabOperator {
	mock := &MockGitlabOperator{ctrl: ctrl}
	mock.recorder = &MockGitlabOperatorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGitlabOperator) EXPECT() *MockGitlabOperatorMockRecorder {
	return m.recorder
}

// AddDeployKey mocks base method.
func (m *MockGitlabOperator) AddDeployKey(pid interface{}, opt *go_gitlab.AddDeployKeyOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AddDeployKey", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AddDeployKey indicates an expected call of AddDeployKey.
func (mr *MockGitlabOperatorMockRecorder) AddDeployKey(pid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddDeployKey", reflect.TypeOf((*MockGitlabOperator)(nil).AddDeployKey), varargs...)
}

// CreateGroup mocks base method.
func (m *MockGitlabOperator) CreateGroup(opt *go_gitlab.CreateGroupOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Group, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateGroup", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Group)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateGroup indicates an expected call of CreateGroup.
func (mr *MockGitlabOperatorMockRecorder) CreateGroup(opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateGroup", reflect.TypeOf((*MockGitlabOperator)(nil).CreateGroup), varargs...)
}

// CreateProject mocks base method.
func (m *MockGitlabOperator) CreateProject(opt *go_gitlab.CreateProjectOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Project, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProject", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Project)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProject indicates an expected call of CreateProject.
func (mr *MockGitlabOperatorMockRecorder) CreateProject(opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProject", reflect.TypeOf((*MockGitlabOperator)(nil).CreateProject), varargs...)
}

// CreateProjectAccessToken mocks base method.
func (m *MockGitlabOperator) CreateProjectAccessToken(pid interface{}, opt *go_gitlab.CreateProjectAccessTokenOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectAccessToken, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateProjectAccessToken", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectAccessToken)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// CreateProjectAccessToken indicates an expected call of CreateProjectAccessToken.
func (mr *MockGitlabOperatorMockRecorder) CreateProjectAccessToken(pid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProjectAccessToken", reflect.TypeOf((*MockGitlabOperator)(nil).CreateProjectAccessToken), varargs...)
}

// DeleteDeployKey mocks base method.
func (m *MockGitlabOperator) DeleteDeployKey(pid interface{}, deployKey int, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, deployKey}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteDeployKey", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteDeployKey indicates an expected call of DeleteDeployKey.
func (mr *MockGitlabOperatorMockRecorder) DeleteDeployKey(pid, deployKey interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, deployKey}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteDeployKey", reflect.TypeOf((*MockGitlabOperator)(nil).DeleteDeployKey), varargs...)
}

// DeleteGroup mocks base method.
func (m *MockGitlabOperator) DeleteGroup(gid interface{}, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{gid}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteGroup", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteGroup indicates an expected call of DeleteGroup.
func (mr *MockGitlabOperatorMockRecorder) DeleteGroup(gid interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{gid}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteGroup", reflect.TypeOf((*MockGitlabOperator)(nil).DeleteGroup), varargs...)
}

// DeleteProject mocks base method.
func (m *MockGitlabOperator) DeleteProject(pid interface{}) (*go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteProject", pid)
	ret0, _ := ret[0].(*go_gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProject indicates an expected call of DeleteProject.
func (mr *MockGitlabOperatorMockRecorder) DeleteProject(pid interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProject", reflect.TypeOf((*MockGitlabOperator)(nil).DeleteProject), pid)
}

// DeleteProjectAccessToken mocks base method.
func (m *MockGitlabOperator) DeleteProjectAccessToken(pid interface{}, id int, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, id}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteProjectAccessToken", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Response)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteProjectAccessToken indicates an expected call of DeleteProjectAccessToken.
func (mr *MockGitlabOperatorMockRecorder) DeleteProjectAccessToken(pid, id interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, id}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProjectAccessToken", reflect.TypeOf((*MockGitlabOperator)(nil).DeleteProjectAccessToken), varargs...)
}

// EnableProjectDeployKey mocks base method.
func (m *MockGitlabOperator) EnableProjectDeployKey(pid interface{}, deployKey int, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, deployKey}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "EnableProjectDeployKey", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// EnableProjectDeployKey indicates an expected call of EnableProjectDeployKey.
func (mr *MockGitlabOperatorMockRecorder) EnableProjectDeployKey(pid, deployKey interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, deployKey}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnableProjectDeployKey", reflect.TypeOf((*MockGitlabOperator)(nil).EnableProjectDeployKey), varargs...)
}

// GetCurrentUser mocks base method.
func (m *MockGitlabOperator) GetCurrentUser() (*go_gitlab.User, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetCurrentUser")
	ret0, _ := ret[0].(*go_gitlab.User)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetCurrentUser indicates an expected call of GetCurrentUser.
func (mr *MockGitlabOperatorMockRecorder) GetCurrentUser() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetCurrentUser", reflect.TypeOf((*MockGitlabOperator)(nil).GetCurrentUser))
}

// GetDeployKey mocks base method.
func (m *MockGitlabOperator) GetDeployKey(pid interface{}, deployKeyID int, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, deployKeyID}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetDeployKey", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetDeployKey indicates an expected call of GetDeployKey.
func (mr *MockGitlabOperatorMockRecorder) GetDeployKey(pid, deployKeyID interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, deployKeyID}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDeployKey", reflect.TypeOf((*MockGitlabOperator)(nil).GetDeployKey), varargs...)
}

// GetGroup mocks base method.
func (m *MockGitlabOperator) GetGroup(gid interface{}, opt *go_gitlab.GetGroupOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Group, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetGroup", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Group)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetGroup indicates an expected call of GetGroup.
func (mr *MockGitlabOperatorMockRecorder) GetGroup(gid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{gid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetGroup", reflect.TypeOf((*MockGitlabOperator)(nil).GetGroup), varargs...)
}

// GetProject mocks base method.
func (m *MockGitlabOperator) GetProject(pid interface{}, opt *go_gitlab.GetProjectOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Project, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProject", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Project)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProject indicates an expected call of GetProject.
func (mr *MockGitlabOperatorMockRecorder) GetProject(pid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProject", reflect.TypeOf((*MockGitlabOperator)(nil).GetProject), varargs...)
}

// GetProjectAccessToken mocks base method.
func (m *MockGitlabOperator) GetProjectAccessToken(pid interface{}, id int, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectAccessToken, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, id}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetProjectAccessToken", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectAccessToken)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// GetProjectAccessToken indicates an expected call of GetProjectAccessToken.
func (mr *MockGitlabOperatorMockRecorder) GetProjectAccessToken(pid, id interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, id}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetProjectAccessToken", reflect.TypeOf((*MockGitlabOperator)(nil).GetProjectAccessToken), varargs...)
}

// ListAllDeployKeys mocks base method.
func (m *MockGitlabOperator) ListAllDeployKeys(opt *go_gitlab.ListInstanceDeployKeysOptions, options ...go_gitlab.RequestOptionFunc) ([]*go_gitlab.InstanceDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAllDeployKeys", varargs...)
	ret0, _ := ret[0].([]*go_gitlab.InstanceDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListAllDeployKeys indicates an expected call of ListAllDeployKeys.
func (mr *MockGitlabOperatorMockRecorder) ListAllDeployKeys(opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAllDeployKeys", reflect.TypeOf((*MockGitlabOperator)(nil).ListAllDeployKeys), varargs...)
}

// ListDeployKeys mocks base method.
func (m *MockGitlabOperator) ListDeployKeys(pid interface{}, opt *go_gitlab.ListProjectDeployKeysOptions, options ...go_gitlab.RequestOptionFunc) ([]*go_gitlab.ProjectDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListDeployKeys", varargs...)
	ret0, _ := ret[0].([]*go_gitlab.ProjectDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListDeployKeys indicates an expected call of ListDeployKeys.
func (mr *MockGitlabOperatorMockRecorder) ListDeployKeys(pid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListDeployKeys", reflect.TypeOf((*MockGitlabOperator)(nil).ListDeployKeys), varargs...)
}

// ListGroupProjects mocks base method.
func (m *MockGitlabOperator) ListGroupProjects(gid interface{}, opt *go_gitlab.ListGroupProjectsOptions, options ...go_gitlab.RequestOptionFunc) ([]*go_gitlab.Project, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroupProjects", varargs...)
	ret0, _ := ret[0].([]*go_gitlab.Project)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroupProjects indicates an expected call of ListGroupProjects.
func (mr *MockGitlabOperatorMockRecorder) ListGroupProjects(gid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{gid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroupProjects", reflect.TypeOf((*MockGitlabOperator)(nil).ListGroupProjects), varargs...)
}

// ListGroups mocks base method.
func (m *MockGitlabOperator) ListGroups(opt *go_gitlab.ListGroupsOptions, options ...go_gitlab.RequestOptionFunc) ([]*go_gitlab.Group, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListGroups", varargs...)
	ret0, _ := ret[0].([]*go_gitlab.Group)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListGroups indicates an expected call of ListGroups.
func (mr *MockGitlabOperatorMockRecorder) ListGroups(opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListGroups", reflect.TypeOf((*MockGitlabOperator)(nil).ListGroups), varargs...)
}

// ListProjectAccessToken mocks base method.
func (m *MockGitlabOperator) ListProjectAccessToken(pid interface{}, opt *go_gitlab.ListProjectAccessTokensOptions, options ...go_gitlab.RequestOptionFunc) ([]*go_gitlab.ProjectAccessToken, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListProjectAccessToken", varargs...)
	ret0, _ := ret[0].([]*go_gitlab.ProjectAccessToken)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjectAccessToken indicates an expected call of ListProjectAccessToken.
func (mr *MockGitlabOperatorMockRecorder) ListProjectAccessToken(pid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjectAccessToken", reflect.TypeOf((*MockGitlabOperator)(nil).ListProjectAccessToken), varargs...)
}

// ListProjects mocks base method.
func (m *MockGitlabOperator) ListProjects(search string) ([]*go_gitlab.Project, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ListProjects", search)
	ret0, _ := ret[0].([]*go_gitlab.Project)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// ListProjects indicates an expected call of ListProjects.
func (mr *MockGitlabOperatorMockRecorder) ListProjects(search interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListProjects", reflect.TypeOf((*MockGitlabOperator)(nil).ListProjects), search)
}

// NewGitlabClient mocks base method.
func (m *MockGitlabOperator) NewGitlabClient(url, token string) (GitlabOperator, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewGitlabClient", url, token)
	ret0, _ := ret[0].(GitlabOperator)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// NewGitlabClient indicates an expected call of NewGitlabClient.
func (mr *MockGitlabOperatorMockRecorder) NewGitlabClient(url, token interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewGitlabClient", reflect.TypeOf((*MockGitlabOperator)(nil).NewGitlabClient), url, token)
}

// UpdateGroup mocks base method.
func (m *MockGitlabOperator) UpdateGroup(gid interface{}, opt *go_gitlab.UpdateGroupOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.Group, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{gid, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateGroup", varargs...)
	ret0, _ := ret[0].(*go_gitlab.Group)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateGroup indicates an expected call of UpdateGroup.
func (mr *MockGitlabOperatorMockRecorder) UpdateGroup(gid, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{gid, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateGroup", reflect.TypeOf((*MockGitlabOperator)(nil).UpdateGroup), varargs...)
}

// UpdateProject mocks base method.
func (m *MockGitlabOperator) UpdateProject(pid interface{}, opt *go_gitlab.EditProjectOptions) (*go_gitlab.Project, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateProject", pid, opt)
	ret0, _ := ret[0].(*go_gitlab.Project)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateProject indicates an expected call of UpdateProject.
func (mr *MockGitlabOperatorMockRecorder) UpdateProject(pid, opt interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateProject", reflect.TypeOf((*MockGitlabOperator)(nil).UpdateProject), pid, opt)
}

// UpdateProjectDeployKey mocks base method.
func (m *MockGitlabOperator) UpdateProjectDeployKey(pid interface{}, deployKey int, opt *go_gitlab.UpdateDeployKeyOptions, options ...go_gitlab.RequestOptionFunc) (*go_gitlab.ProjectDeployKey, *go_gitlab.Response, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{pid, deployKey, opt}
	for _, a := range options {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "UpdateProjectDeployKey", varargs...)
	ret0, _ := ret[0].(*go_gitlab.ProjectDeployKey)
	ret1, _ := ret[1].(*go_gitlab.Response)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// UpdateProjectDeployKey indicates an expected call of UpdateProjectDeployKey.
func (mr *MockGitlabOperatorMockRecorder) UpdateProjectDeployKey(pid, deployKey, opt interface{}, options ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{pid, deployKey, opt}, options...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateProjectDeployKey", reflect.TypeOf((*MockGitlabOperator)(nil).UpdateProjectDeployKey), varargs...)
}
