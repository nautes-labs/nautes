// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/vaultproxy/v1/vaultproxy.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SecretInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretInfoMultiError, or
// nil if none found.
func (m *SecretInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Path

	// no validation rules for Version

	if len(errors) > 0 {
		return SecretInfoMultiError(errors)
	}

	return nil
}

// SecretInfoMultiError is an error wrapping multiple validation errors
// returned by SecretInfo.ValidateAll() if the designated constraints aren't met.
type SecretInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretInfoMultiError) AllErrors() []error { return m }

// SecretInfoValidationError is the validation error returned by
// SecretInfo.Validate if the designated constraints aren't met.
type SecretInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretInfoValidationError) ErrorName() string { return "SecretInfoValidationError" }

// Error satisfies the builtin error interface
func (e SecretInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretInfoValidationError{}

// Validate checks the field values on GitKVs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GitKVs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GitKVs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GitKVsMultiError, or nil if none found.
func (m *GitKVs) ValidateAll() error {
	return m.validate(true)
}

func (m *GitKVs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DeployKey

	// no validation rules for AccessToken

	// no validation rules for Additionals

	if len(errors) > 0 {
		return GitKVsMultiError(errors)
	}

	return nil
}

// GitKVsMultiError is an error wrapping multiple validation errors returned by
// GitKVs.ValidateAll() if the designated constraints aren't met.
type GitKVsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GitKVsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GitKVsMultiError) AllErrors() []error { return m }

// GitKVsValidationError is the validation error returned by GitKVs.Validate if
// the designated constraints aren't met.
type GitKVsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GitKVsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GitKVsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GitKVsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GitKVsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GitKVsValidationError) ErrorName() string { return "GitKVsValidationError" }

// Error satisfies the builtin error interface
func (e GitKVsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGitKVs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GitKVsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GitKVsValidationError{}

// Validate checks the field values on GitMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GitMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GitMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GitMetaMultiError, or nil if none found.
func (m *GitMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *GitMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProviderType()) < 1 {
		err := GitMetaValidationError{
			field:  "ProviderType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := GitMetaValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := GitMetaValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPermission()) < 1 {
		err := GitMetaValidationError{
			field:  "Permission",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GitMetaMultiError(errors)
	}

	return nil
}

// GitMetaMultiError is an error wrapping multiple validation errors returned
// by GitMeta.ValidateAll() if the designated constraints aren't met.
type GitMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GitMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GitMetaMultiError) AllErrors() []error { return m }

// GitMetaValidationError is the validation error returned by GitMeta.Validate
// if the designated constraints aren't met.
type GitMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GitMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GitMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GitMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GitMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GitMetaValidationError) ErrorName() string { return "GitMetaValidationError" }

// Error satisfies the builtin error interface
func (e GitMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGitMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GitMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GitMetaValidationError{}

// Validate checks the field values on GitRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GitRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GitRequestMultiError, or
// nil if none found.
func (m *GitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := GitRequestValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GitRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GitRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GitRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetKvs() == nil {
		err := GitRequestValidationError{
			field:  "Kvs",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKvs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GitRequestValidationError{
					field:  "Kvs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GitRequestValidationError{
					field:  "Kvs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKvs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GitRequestValidationError{
				field:  "Kvs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GitRequestMultiError(errors)
	}

	return nil
}

// GitRequestMultiError is an error wrapping multiple validation errors
// returned by GitRequest.ValidateAll() if the designated constraints aren't met.
type GitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GitRequestMultiError) AllErrors() []error { return m }

// GitRequestValidationError is the validation error returned by
// GitRequest.Validate if the designated constraints aren't met.
type GitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GitRequestValidationError) ErrorName() string { return "GitRequestValidationError" }

// Error satisfies the builtin error interface
func (e GitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GitRequestValidationError{}

// Validate checks the field values on CreateGitReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateGitReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateGitReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateGitReplyMultiError,
// or nil if none found.
func (m *CreateGitReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateGitReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateGitReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateGitReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateGitReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateGitReplyMultiError(errors)
	}

	return nil
}

// CreateGitReplyMultiError is an error wrapping multiple validation errors
// returned by CreateGitReply.ValidateAll() if the designated constraints
// aren't met.
type CreateGitReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateGitReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateGitReplyMultiError) AllErrors() []error { return m }

// CreateGitReplyValidationError is the validation error returned by
// CreateGitReply.Validate if the designated constraints aren't met.
type CreateGitReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateGitReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateGitReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateGitReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateGitReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateGitReplyValidationError) ErrorName() string { return "CreateGitReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateGitReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateGitReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateGitReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateGitReplyValidationError{}

// Validate checks the field values on DeleteGitReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteGitReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteGitReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteGitReplyMultiError,
// or nil if none found.
func (m *DeleteGitReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteGitReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteGitReplyMultiError(errors)
	}

	return nil
}

// DeleteGitReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteGitReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteGitReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteGitReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteGitReplyMultiError) AllErrors() []error { return m }

// DeleteGitReplyValidationError is the validation error returned by
// DeleteGitReply.Validate if the designated constraints aren't met.
type DeleteGitReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteGitReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteGitReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteGitReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteGitReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteGitReplyValidationError) ErrorName() string { return "DeleteGitReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteGitReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteGitReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteGitReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteGitReplyValidationError{}

// Validate checks the field values on PkiRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PkiRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PkiRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PkiRequestMultiError, or
// nil if none found.
func (m *PkiRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PkiRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Domain

	// no validation rules for Cacert

	// no validation rules for Cert

	// no validation rules for Key

	if len(errors) > 0 {
		return PkiRequestMultiError(errors)
	}

	return nil
}

// PkiRequestMultiError is an error wrapping multiple validation errors
// returned by PkiRequest.ValidateAll() if the designated constraints aren't met.
type PkiRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PkiRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PkiRequestMultiError) AllErrors() []error { return m }

// PkiRequestValidationError is the validation error returned by
// PkiRequest.Validate if the designated constraints aren't met.
type PkiRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PkiRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PkiRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PkiRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PkiRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PkiRequestValidationError) ErrorName() string { return "PkiRequestValidationError" }

// Error satisfies the builtin error interface
func (e PkiRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPkiRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PkiRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PkiRequestValidationError{}

// Validate checks the field values on CreatePkiReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreatePkiReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePkiReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreatePkiReplyMultiError,
// or nil if none found.
func (m *CreatePkiReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePkiReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePkiReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePkiReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePkiReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePkiReplyMultiError(errors)
	}

	return nil
}

// CreatePkiReplyMultiError is an error wrapping multiple validation errors
// returned by CreatePkiReply.ValidateAll() if the designated constraints
// aren't met.
type CreatePkiReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePkiReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePkiReplyMultiError) AllErrors() []error { return m }

// CreatePkiReplyValidationError is the validation error returned by
// CreatePkiReply.Validate if the designated constraints aren't met.
type CreatePkiReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePkiReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePkiReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePkiReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePkiReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePkiReplyValidationError) ErrorName() string { return "CreatePkiReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreatePkiReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePkiReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePkiReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePkiReplyValidationError{}

// Validate checks the field values on DeletePkiReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeletePkiReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePkiReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeletePkiReplyMultiError,
// or nil if none found.
func (m *DeletePkiReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePkiReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeletePkiReplyMultiError(errors)
	}

	return nil
}

// DeletePkiReplyMultiError is an error wrapping multiple validation errors
// returned by DeletePkiReply.ValidateAll() if the designated constraints
// aren't met.
type DeletePkiReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePkiReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePkiReplyMultiError) AllErrors() []error { return m }

// DeletePkiReplyValidationError is the validation error returned by
// DeletePkiReply.Validate if the designated constraints aren't met.
type DeletePkiReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePkiReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePkiReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePkiReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePkiReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePkiReplyValidationError) ErrorName() string { return "DeletePkiReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeletePkiReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePkiReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePkiReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePkiReplyValidationError{}

// Validate checks the field values on RepoAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoAccountMultiError, or
// nil if none found.
func (m *RepoAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Username

	// no validation rules for Password

	if len(errors) > 0 {
		return RepoAccountMultiError(errors)
	}

	return nil
}

// RepoAccountMultiError is an error wrapping multiple validation errors
// returned by RepoAccount.ValidateAll() if the designated constraints aren't met.
type RepoAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoAccountMultiError) AllErrors() []error { return m }

// RepoAccountValidationError is the validation error returned by
// RepoAccount.Validate if the designated constraints aren't met.
type RepoAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoAccountValidationError) ErrorName() string { return "RepoAccountValidationError" }

// Error satisfies the builtin error interface
func (e RepoAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoAccountValidationError{}

// Validate checks the field values on RepoMeta with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoMetaMultiError, or nil
// if none found.
func (m *RepoMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetProviderId()) < 1 {
		err := RepoMetaValidationError{
			field:  "ProviderId",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := RepoMetaValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := RepoMetaValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := RepoMetaValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPermission()) < 1 {
		err := RepoMetaValidationError{
			field:  "Permission",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RepoMetaMultiError(errors)
	}

	return nil
}

// RepoMetaMultiError is an error wrapping multiple validation errors returned
// by RepoMeta.ValidateAll() if the designated constraints aren't met.
type RepoMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoMetaMultiError) AllErrors() []error { return m }

// RepoMetaValidationError is the validation error returned by
// RepoMeta.Validate if the designated constraints aren't met.
type RepoMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoMetaValidationError) ErrorName() string { return "RepoMetaValidationError" }

// Error satisfies the builtin error interface
func (e RepoMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoMetaValidationError{}

// Validate checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoRequestMultiError, or
// nil if none found.
func (m *RepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := RepoRequestValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAccount() == nil {
		err := RepoRequestValidationError{
			field:  "Account",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepoRequestMultiError(errors)
	}

	return nil
}

// RepoRequestMultiError is an error wrapping multiple validation errors
// returned by RepoRequest.ValidateAll() if the designated constraints aren't met.
type RepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoRequestMultiError) AllErrors() []error { return m }

// RepoRequestValidationError is the validation error returned by
// RepoRequest.Validate if the designated constraints aren't met.
type RepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoRequestValidationError) ErrorName() string { return "RepoRequestValidationError" }

// Error satisfies the builtin error interface
func (e RepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoRequestValidationError{}

// Validate checks the field values on CreateRepoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateRepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepoReplyMultiError, or nil if none found.
func (m *CreateRepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepoReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepoReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepoReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateRepoReplyMultiError(errors)
	}

	return nil
}

// CreateRepoReplyMultiError is an error wrapping multiple validation errors
// returned by CreateRepoReply.ValidateAll() if the designated constraints
// aren't met.
type CreateRepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepoReplyMultiError) AllErrors() []error { return m }

// CreateRepoReplyValidationError is the validation error returned by
// CreateRepoReply.Validate if the designated constraints aren't met.
type CreateRepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepoReplyValidationError) ErrorName() string { return "CreateRepoReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateRepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepoReplyValidationError{}

// Validate checks the field values on DeleteRepoReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepoReplyMultiError, or nil if none found.
func (m *DeleteRepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteRepoReplyMultiError(errors)
	}

	return nil
}

// DeleteRepoReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteRepoReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteRepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepoReplyMultiError) AllErrors() []error { return m }

// DeleteRepoReplyValidationError is the validation error returned by
// DeleteRepoReply.Validate if the designated constraints aren't met.
type DeleteRepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepoReplyValidationError) ErrorName() string { return "DeleteRepoReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepoReplyValidationError{}

// Validate checks the field values on TenantGitMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TenantGitMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TenantGitMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TenantGitMetaMultiError, or
// nil if none found.
func (m *TenantGitMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *TenantGitMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := TenantGitMetaValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPermission()) < 1 {
		err := TenantGitMetaValidationError{
			field:  "Permission",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TenantGitMetaMultiError(errors)
	}

	return nil
}

// TenantGitMetaMultiError is an error wrapping multiple validation errors
// returned by TenantGitMeta.ValidateAll() if the designated constraints
// aren't met.
type TenantGitMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantGitMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantGitMetaMultiError) AllErrors() []error { return m }

// TenantGitMetaValidationError is the validation error returned by
// TenantGitMeta.Validate if the designated constraints aren't met.
type TenantGitMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantGitMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantGitMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantGitMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantGitMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantGitMetaValidationError) ErrorName() string { return "TenantGitMetaValidationError" }

// Error satisfies the builtin error interface
func (e TenantGitMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantGitMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantGitMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantGitMetaValidationError{}

// Validate checks the field values on TenantGitRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TenantGitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TenantGitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TenantGitRequestMultiError, or nil if none found.
func (m *TenantGitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TenantGitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := TenantGitRequestValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantGitRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantGitRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantGitRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetKvs() == nil {
		err := TenantGitRequestValidationError{
			field:  "Kvs",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKvs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantGitRequestValidationError{
					field:  "Kvs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantGitRequestValidationError{
					field:  "Kvs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKvs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantGitRequestValidationError{
				field:  "Kvs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TenantGitRequestMultiError(errors)
	}

	return nil
}

// TenantGitRequestMultiError is an error wrapping multiple validation errors
// returned by TenantGitRequest.ValidateAll() if the designated constraints
// aren't met.
type TenantGitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantGitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantGitRequestMultiError) AllErrors() []error { return m }

// TenantGitRequestValidationError is the validation error returned by
// TenantGitRequest.Validate if the designated constraints aren't met.
type TenantGitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantGitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantGitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantGitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantGitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantGitRequestValidationError) ErrorName() string { return "TenantGitRequestValidationError" }

// Error satisfies the builtin error interface
func (e TenantGitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantGitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantGitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantGitRequestValidationError{}

// Validate checks the field values on CreateTenantGitReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTenantGitReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTenantGitReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTenantGitReplyMultiError, or nil if none found.
func (m *CreateTenantGitReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTenantGitReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTenantGitReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTenantGitReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTenantGitReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTenantGitReplyMultiError(errors)
	}

	return nil
}

// CreateTenantGitReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTenantGitReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTenantGitReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTenantGitReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTenantGitReplyMultiError) AllErrors() []error { return m }

// CreateTenantGitReplyValidationError is the validation error returned by
// CreateTenantGitReply.Validate if the designated constraints aren't met.
type CreateTenantGitReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTenantGitReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTenantGitReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTenantGitReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTenantGitReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTenantGitReplyValidationError) ErrorName() string {
	return "CreateTenantGitReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTenantGitReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTenantGitReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTenantGitReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTenantGitReplyValidationError{}

// Validate checks the field values on DeleteTenantGitReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTenantGitReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTenantGitReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTenantGitReplyMultiError, or nil if none found.
func (m *DeleteTenantGitReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTenantGitReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteTenantGitReplyMultiError(errors)
	}

	return nil
}

// DeleteTenantGitReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteTenantGitReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteTenantGitReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTenantGitReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTenantGitReplyMultiError) AllErrors() []error { return m }

// DeleteTenantGitReplyValidationError is the validation error returned by
// DeleteTenantGitReply.Validate if the designated constraints aren't met.
type DeleteTenantGitReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTenantGitReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTenantGitReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTenantGitReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTenantGitReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTenantGitReplyValidationError) ErrorName() string {
	return "DeleteTenantGitReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTenantGitReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTenantGitReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTenantGitReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTenantGitReplyValidationError{}

// Validate checks the field values on TenantRepoMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TenantRepoMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TenantRepoMeta with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TenantRepoMetaMultiError,
// or nil if none found.
func (m *TenantRepoMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *TenantRepoMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := TenantRepoMetaValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPermission()) < 1 {
		err := TenantRepoMetaValidationError{
			field:  "Permission",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return TenantRepoMetaMultiError(errors)
	}

	return nil
}

// TenantRepoMetaMultiError is an error wrapping multiple validation errors
// returned by TenantRepoMeta.ValidateAll() if the designated constraints
// aren't met.
type TenantRepoMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantRepoMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantRepoMetaMultiError) AllErrors() []error { return m }

// TenantRepoMetaValidationError is the validation error returned by
// TenantRepoMeta.Validate if the designated constraints aren't met.
type TenantRepoMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantRepoMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantRepoMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantRepoMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantRepoMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantRepoMetaValidationError) ErrorName() string { return "TenantRepoMetaValidationError" }

// Error satisfies the builtin error interface
func (e TenantRepoMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantRepoMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantRepoMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantRepoMetaValidationError{}

// Validate checks the field values on TenantRepoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TenantRepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TenantRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TenantRepoRequestMultiError, or nil if none found.
func (m *TenantRepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TenantRepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := TenantRepoRequestValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantRepoRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantRepoRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantRepoRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAccount() == nil {
		err := TenantRepoRequestValidationError{
			field:  "Account",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TenantRepoRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TenantRepoRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TenantRepoRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TenantRepoRequestMultiError(errors)
	}

	return nil
}

// TenantRepoRequestMultiError is an error wrapping multiple validation errors
// returned by TenantRepoRequest.ValidateAll() if the designated constraints
// aren't met.
type TenantRepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TenantRepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TenantRepoRequestMultiError) AllErrors() []error { return m }

// TenantRepoRequestValidationError is the validation error returned by
// TenantRepoRequest.Validate if the designated constraints aren't met.
type TenantRepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantRepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantRepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantRepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantRepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantRepoRequestValidationError) ErrorName() string {
	return "TenantRepoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TenantRepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantRepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantRepoRequestValidationError{}

// Validate checks the field values on CreateTenantRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTenantRepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTenantRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTenantRepoReplyMultiError, or nil if none found.
func (m *CreateTenantRepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTenantRepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateTenantRepoReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateTenantRepoReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateTenantRepoReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateTenantRepoReplyMultiError(errors)
	}

	return nil
}

// CreateTenantRepoReplyMultiError is an error wrapping multiple validation
// errors returned by CreateTenantRepoReply.ValidateAll() if the designated
// constraints aren't met.
type CreateTenantRepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTenantRepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTenantRepoReplyMultiError) AllErrors() []error { return m }

// CreateTenantRepoReplyValidationError is the validation error returned by
// CreateTenantRepoReply.Validate if the designated constraints aren't met.
type CreateTenantRepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTenantRepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTenantRepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTenantRepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTenantRepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTenantRepoReplyValidationError) ErrorName() string {
	return "CreateTenantRepoReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTenantRepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTenantRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTenantRepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTenantRepoReplyValidationError{}

// Validate checks the field values on DeleteTenantRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteTenantRepoReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteTenantRepoReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteTenantRepoReplyMultiError, or nil if none found.
func (m *DeleteTenantRepoReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteTenantRepoReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteTenantRepoReplyMultiError(errors)
	}

	return nil
}

// DeleteTenantRepoReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteTenantRepoReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteTenantRepoReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTenantRepoReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTenantRepoReplyMultiError) AllErrors() []error { return m }

// DeleteTenantRepoReplyValidationError is the validation error returned by
// DeleteTenantRepoReply.Validate if the designated constraints aren't met.
type DeleteTenantRepoReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTenantRepoReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTenantRepoReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTenantRepoReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTenantRepoReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTenantRepoReplyValidationError) ErrorName() string {
	return "DeleteTenantRepoReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTenantRepoReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTenantRepoReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTenantRepoReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTenantRepoReplyValidationError{}

// Validate checks the field values on ClusterAccount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterAccountMultiError,
// or nil if none found.
func (m *ClusterAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kubeconfig

	if len(errors) > 0 {
		return ClusterAccountMultiError(errors)
	}

	return nil
}

// ClusterAccountMultiError is an error wrapping multiple validation errors
// returned by ClusterAccount.ValidateAll() if the designated constraints
// aren't met.
type ClusterAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterAccountMultiError) AllErrors() []error { return m }

// ClusterAccountValidationError is the validation error returned by
// ClusterAccount.Validate if the designated constraints aren't met.
type ClusterAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterAccountValidationError) ErrorName() string { return "ClusterAccountValidationError" }

// Error satisfies the builtin error interface
func (e ClusterAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterAccountValidationError{}

// Validate checks the field values on ClusterMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterMeta with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterMetaMultiError, or
// nil if none found.
func (m *ClusterMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetType()) < 1 {
		err := ClusterMetaValidationError{
			field:  "Type",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetId()) < 1 {
		err := ClusterMetaValidationError{
			field:  "Id",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetUsername()) < 1 {
		err := ClusterMetaValidationError{
			field:  "Username",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPermission()) < 1 {
		err := ClusterMetaValidationError{
			field:  "Permission",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ClusterMetaMultiError(errors)
	}

	return nil
}

// ClusterMetaMultiError is an error wrapping multiple validation errors
// returned by ClusterMeta.ValidateAll() if the designated constraints aren't met.
type ClusterMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterMetaMultiError) AllErrors() []error { return m }

// ClusterMetaValidationError is the validation error returned by
// ClusterMeta.Validate if the designated constraints aren't met.
type ClusterMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterMetaValidationError) ErrorName() string { return "ClusterMetaValidationError" }

// Error satisfies the builtin error interface
func (e ClusterMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterMetaValidationError{}

// Validate checks the field values on ClusterRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterRequestMultiError,
// or nil if none found.
func (m *ClusterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMeta() == nil {
		err := ClusterRequestValidationError{
			field:  "Meta",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterRequestValidationError{
					field:  "Meta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterRequestValidationError{
				field:  "Meta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAccount() == nil {
		err := ClusterRequestValidationError{
			field:  "Account",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetAccount()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterRequestValidationError{
					field:  "Account",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAccount()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterRequestValidationError{
				field:  "Account",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterRequestMultiError(errors)
	}

	return nil
}

// ClusterRequestMultiError is an error wrapping multiple validation errors
// returned by ClusterRequest.ValidateAll() if the designated constraints
// aren't met.
type ClusterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterRequestMultiError) AllErrors() []error { return m }

// ClusterRequestValidationError is the validation error returned by
// ClusterRequest.Validate if the designated constraints aren't met.
type ClusterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterRequestValidationError) ErrorName() string { return "ClusterRequestValidationError" }

// Error satisfies the builtin error interface
func (e ClusterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterRequestValidationError{}

// Validate checks the field values on CreateClusterReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateClusterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateClusterReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateClusterReplyMultiError, or nil if none found.
func (m *CreateClusterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateClusterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateClusterReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateClusterReplyValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateClusterReplyValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateClusterReplyMultiError(errors)
	}

	return nil
}

// CreateClusterReplyMultiError is an error wrapping multiple validation errors
// returned by CreateClusterReply.ValidateAll() if the designated constraints
// aren't met.
type CreateClusterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateClusterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateClusterReplyMultiError) AllErrors() []error { return m }

// CreateClusterReplyValidationError is the validation error returned by
// CreateClusterReply.Validate if the designated constraints aren't met.
type CreateClusterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateClusterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateClusterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateClusterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateClusterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateClusterReplyValidationError) ErrorName() string {
	return "CreateClusterReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateClusterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateClusterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateClusterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateClusterReplyValidationError{}

// Validate checks the field values on DeleteClusterReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteClusterReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteClusterReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteClusterReplyMultiError, or nil if none found.
func (m *DeleteClusterReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteClusterReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteClusterReplyMultiError(errors)
	}

	return nil
}

// DeleteClusterReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteClusterReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteClusterReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteClusterReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteClusterReplyMultiError) AllErrors() []error { return m }

// DeleteClusterReplyValidationError is the validation error returned by
// DeleteClusterReply.Validate if the designated constraints aren't met.
type DeleteClusterReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteClusterReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteClusterReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteClusterReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteClusterReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteClusterReplyValidationError) ErrorName() string {
	return "DeleteClusterReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteClusterReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteClusterReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteClusterReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteClusterReplyValidationError{}

// Validate checks the field values on Kubernetes with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Kubernetes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Kubernetes with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KubernetesMultiError, or
// nil if none found.
func (m *Kubernetes) ValidateAll() error {
	return m.validate(true)
}

func (m *Kubernetes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetUrl()) < 1 {
		err := KubernetesValidationError{
			field:  "Url",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Cabundle

	if utf8.RuneCountInString(m.GetToken()) < 1 {
		err := KubernetesValidationError{
			field:  "Token",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return KubernetesMultiError(errors)
	}

	return nil
}

// KubernetesMultiError is an error wrapping multiple validation errors
// returned by Kubernetes.ValidateAll() if the designated constraints aren't met.
type KubernetesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubernetesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubernetesMultiError) AllErrors() []error { return m }

// KubernetesValidationError is the validation error returned by
// Kubernetes.Validate if the designated constraints aren't met.
type KubernetesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubernetesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubernetesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubernetesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubernetesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubernetesValidationError) ErrorName() string { return "KubernetesValidationError" }

// Error satisfies the builtin error interface
func (e KubernetesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubernetes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubernetesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubernetesValidationError{}

// Validate checks the field values on AuthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthRequestMultiError, or
// nil if none found.
func (m *AuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAuthType()) < 1 {
		err := AuthRequestValidationError{
			field:  "AuthType",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetKubernetes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthRequestValidationError{
					field:  "Kubernetes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthRequestValidationError{
					field:  "Kubernetes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKubernetes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthRequestValidationError{
				field:  "Kubernetes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthRequestMultiError(errors)
	}

	return nil
}

// AuthRequestMultiError is an error wrapping multiple validation errors
// returned by AuthRequest.ValidateAll() if the designated constraints aren't met.
type AuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthRequestMultiError) AllErrors() []error { return m }

// AuthRequestValidationError is the validation error returned by
// AuthRequest.Validate if the designated constraints aren't met.
type AuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthRequestValidationError) ErrorName() string { return "AuthRequestValidationError" }

// Error satisfies the builtin error interface
func (e AuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthRequestValidationError{}

// Validate checks the field values on CreateAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAuthReplyMultiError, or nil if none found.
func (m *CreateAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return CreateAuthReplyMultiError(errors)
	}

	return nil
}

// CreateAuthReplyMultiError is an error wrapping multiple validation errors
// returned by CreateAuthReply.ValidateAll() if the designated constraints
// aren't met.
type CreateAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAuthReplyMultiError) AllErrors() []error { return m }

// CreateAuthReplyValidationError is the validation error returned by
// CreateAuthReply.Validate if the designated constraints aren't met.
type CreateAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAuthReplyValidationError) ErrorName() string { return "CreateAuthReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAuthReplyValidationError{}

// Validate checks the field values on DeleteAuthReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteAuthReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAuthReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAuthReplyMultiError, or nil if none found.
func (m *DeleteAuthReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAuthReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteAuthReplyMultiError(errors)
	}

	return nil
}

// DeleteAuthReplyMultiError is an error wrapping multiple validation errors
// returned by DeleteAuthReply.ValidateAll() if the designated constraints
// aren't met.
type DeleteAuthReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAuthReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAuthReplyMultiError) AllErrors() []error { return m }

// DeleteAuthReplyValidationError is the validation error returned by
// DeleteAuthReply.Validate if the designated constraints aren't met.
type DeleteAuthReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAuthReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAuthReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAuthReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAuthReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAuthReplyValidationError) ErrorName() string { return "DeleteAuthReplyValidationError" }

// Error satisfies the builtin error interface
func (e DeleteAuthReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAuthReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAuthReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAuthReplyValidationError{}

// Validate checks the field values on KubernetesAuthRoleMeta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *KubernetesAuthRoleMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KubernetesAuthRoleMeta with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// KubernetesAuthRoleMetaMultiError, or nil if none found.
func (m *KubernetesAuthRoleMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *KubernetesAuthRoleMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetNamespaces() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := KubernetesAuthRoleMetaValidationError{
				field:  fmt.Sprintf("Namespaces[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	for idx, item := range m.GetServiceAccounts() {
		_, _ = idx, item

		if utf8.RuneCountInString(item) < 1 {
			err := KubernetesAuthRoleMetaValidationError{
				field:  fmt.Sprintf("ServiceAccounts[%v]", idx),
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return KubernetesAuthRoleMetaMultiError(errors)
	}

	return nil
}

// KubernetesAuthRoleMetaMultiError is an error wrapping multiple validation
// errors returned by KubernetesAuthRoleMeta.ValidateAll() if the designated
// constraints aren't met.
type KubernetesAuthRoleMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KubernetesAuthRoleMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KubernetesAuthRoleMetaMultiError) AllErrors() []error { return m }

// KubernetesAuthRoleMetaValidationError is the validation error returned by
// KubernetesAuthRoleMeta.Validate if the designated constraints aren't met.
type KubernetesAuthRoleMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KubernetesAuthRoleMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KubernetesAuthRoleMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KubernetesAuthRoleMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KubernetesAuthRoleMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KubernetesAuthRoleMetaValidationError) ErrorName() string {
	return "KubernetesAuthRoleMetaValidationError"
}

// Error satisfies the builtin error interface
func (e KubernetesAuthRoleMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKubernetesAuthRoleMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KubernetesAuthRoleMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KubernetesAuthRoleMetaValidationError{}

// Validate checks the field values on AuthroleRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AuthroleRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthroleRequestMultiError, or nil if none found.
func (m *AuthroleRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch v := m.Role.(type) {
	case *AuthroleRequest_Kubernetes:
		if v == nil {
			err := AuthroleRequestValidationError{
				field:  "Role",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKubernetes()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AuthroleRequestValidationError{
						field:  "Kubernetes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AuthroleRequestValidationError{
						field:  "Kubernetes",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKubernetes()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AuthroleRequestValidationError{
					field:  "Kubernetes",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AuthroleRequestMultiError(errors)
	}

	return nil
}

// AuthroleRequestMultiError is an error wrapping multiple validation errors
// returned by AuthroleRequest.ValidateAll() if the designated constraints
// aren't met.
type AuthroleRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleRequestMultiError) AllErrors() []error { return m }

// AuthroleRequestValidationError is the validation error returned by
// AuthroleRequest.Validate if the designated constraints aren't met.
type AuthroleRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleRequestValidationError) ErrorName() string { return "AuthroleRequestValidationError" }

// Error satisfies the builtin error interface
func (e AuthroleRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleRequestValidationError{}

// Validate checks the field values on CreateAuthroleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAuthroleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAuthroleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAuthroleReplyMultiError, or nil if none found.
func (m *CreateAuthroleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAuthroleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return CreateAuthroleReplyMultiError(errors)
	}

	return nil
}

// CreateAuthroleReplyMultiError is an error wrapping multiple validation
// errors returned by CreateAuthroleReply.ValidateAll() if the designated
// constraints aren't met.
type CreateAuthroleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAuthroleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAuthroleReplyMultiError) AllErrors() []error { return m }

// CreateAuthroleReplyValidationError is the validation error returned by
// CreateAuthroleReply.Validate if the designated constraints aren't met.
type CreateAuthroleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAuthroleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAuthroleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAuthroleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAuthroleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAuthroleReplyValidationError) ErrorName() string {
	return "CreateAuthroleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAuthroleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAuthroleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAuthroleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAuthroleReplyValidationError{}

// Validate checks the field values on DeleteAuthroleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteAuthroleReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteAuthroleReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteAuthroleReplyMultiError, or nil if none found.
func (m *DeleteAuthroleReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteAuthroleReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return DeleteAuthroleReplyMultiError(errors)
	}

	return nil
}

// DeleteAuthroleReplyMultiError is an error wrapping multiple validation
// errors returned by DeleteAuthroleReply.ValidateAll() if the designated
// constraints aren't met.
type DeleteAuthroleReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAuthroleReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAuthroleReplyMultiError) AllErrors() []error { return m }

// DeleteAuthroleReplyValidationError is the validation error returned by
// DeleteAuthroleReply.Validate if the designated constraints aren't met.
type DeleteAuthroleReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAuthroleReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAuthroleReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAuthroleReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAuthroleReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAuthroleReplyValidationError) ErrorName() string {
	return "DeleteAuthroleReplyValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAuthroleReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAuthroleReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAuthroleReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAuthroleReplyValidationError{}

// Validate checks the field values on AuthroleGitPolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthroleGitPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleGitPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthroleGitPolicyRequestMultiError, or nil if none found.
func (m *AuthroleGitPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleGitPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleGitPolicyRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleGitPolicyRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecret() == nil {
		err := AuthroleGitPolicyRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthroleGitPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthroleGitPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthroleGitPolicyRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthroleGitPolicyRequestMultiError(errors)
	}

	return nil
}

// AuthroleGitPolicyRequestMultiError is an error wrapping multiple validation
// errors returned by AuthroleGitPolicyRequest.ValidateAll() if the designated
// constraints aren't met.
type AuthroleGitPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleGitPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleGitPolicyRequestMultiError) AllErrors() []error { return m }

// AuthroleGitPolicyRequestValidationError is the validation error returned by
// AuthroleGitPolicyRequest.Validate if the designated constraints aren't met.
type AuthroleGitPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleGitPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleGitPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleGitPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleGitPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleGitPolicyRequestValidationError) ErrorName() string {
	return "AuthroleGitPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthroleGitPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleGitPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleGitPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleGitPolicyRequestValidationError{}

// Validate checks the field values on AuthroleRepoPolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthroleRepoPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleRepoPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthroleRepoPolicyRequestMultiError, or nil if none found.
func (m *AuthroleRepoPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleRepoPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleRepoPolicyRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleRepoPolicyRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecret() == nil {
		err := AuthroleRepoPolicyRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthroleRepoPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthroleRepoPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthroleRepoPolicyRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthroleRepoPolicyRequestMultiError(errors)
	}

	return nil
}

// AuthroleRepoPolicyRequestMultiError is an error wrapping multiple validation
// errors returned by AuthroleRepoPolicyRequest.ValidateAll() if the
// designated constraints aren't met.
type AuthroleRepoPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleRepoPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleRepoPolicyRequestMultiError) AllErrors() []error { return m }

// AuthroleRepoPolicyRequestValidationError is the validation error returned by
// AuthroleRepoPolicyRequest.Validate if the designated constraints aren't met.
type AuthroleRepoPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleRepoPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleRepoPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleRepoPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleRepoPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleRepoPolicyRequestValidationError) ErrorName() string {
	return "AuthroleRepoPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthroleRepoPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleRepoPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleRepoPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleRepoPolicyRequestValidationError{}

// Validate checks the field values on AuthroleClusterPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthroleClusterPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleClusterPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AuthroleClusterPolicyRequestMultiError, or nil if none found.
func (m *AuthroleClusterPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleClusterPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleClusterPolicyRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleClusterPolicyRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecret() == nil {
		err := AuthroleClusterPolicyRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthroleClusterPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthroleClusterPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthroleClusterPolicyRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthroleClusterPolicyRequestMultiError(errors)
	}

	return nil
}

// AuthroleClusterPolicyRequestMultiError is an error wrapping multiple
// validation errors returned by AuthroleClusterPolicyRequest.ValidateAll() if
// the designated constraints aren't met.
type AuthroleClusterPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleClusterPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleClusterPolicyRequestMultiError) AllErrors() []error { return m }

// AuthroleClusterPolicyRequestValidationError is the validation error returned
// by AuthroleClusterPolicyRequest.Validate if the designated constraints
// aren't met.
type AuthroleClusterPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleClusterPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleClusterPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleClusterPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleClusterPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleClusterPolicyRequestValidationError) ErrorName() string {
	return "AuthroleClusterPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthroleClusterPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleClusterPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleClusterPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleClusterPolicyRequestValidationError{}

// Validate checks the field values on AuthroleTenantGitPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthroleTenantGitPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleTenantGitPolicyRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AuthroleTenantGitPolicyRequestMultiError, or nil if none found.
func (m *AuthroleTenantGitPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleTenantGitPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleTenantGitPolicyRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleTenantGitPolicyRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecret() == nil {
		err := AuthroleTenantGitPolicyRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthroleTenantGitPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthroleTenantGitPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthroleTenantGitPolicyRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthroleTenantGitPolicyRequestMultiError(errors)
	}

	return nil
}

// AuthroleTenantGitPolicyRequestMultiError is an error wrapping multiple
// validation errors returned by AuthroleTenantGitPolicyRequest.ValidateAll()
// if the designated constraints aren't met.
type AuthroleTenantGitPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleTenantGitPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleTenantGitPolicyRequestMultiError) AllErrors() []error { return m }

// AuthroleTenantGitPolicyRequestValidationError is the validation error
// returned by AuthroleTenantGitPolicyRequest.Validate if the designated
// constraints aren't met.
type AuthroleTenantGitPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleTenantGitPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleTenantGitPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleTenantGitPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleTenantGitPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleTenantGitPolicyRequestValidationError) ErrorName() string {
	return "AuthroleTenantGitPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthroleTenantGitPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleTenantGitPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleTenantGitPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleTenantGitPolicyRequestValidationError{}

// Validate checks the field values on AuthroleTenantRepoPolicyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AuthroleTenantRepoPolicyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthroleTenantRepoPolicyRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AuthroleTenantRepoPolicyRequestMultiError, or nil if none found.
func (m *AuthroleTenantRepoPolicyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthroleTenantRepoPolicyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetClusterName()) < 1 {
		err := AuthroleTenantRepoPolicyRequestValidationError{
			field:  "ClusterName",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetDestUser()) < 1 {
		err := AuthroleTenantRepoPolicyRequestValidationError{
			field:  "DestUser",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSecret() == nil {
		err := AuthroleTenantRepoPolicyRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AuthroleTenantRepoPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AuthroleTenantRepoPolicyRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AuthroleTenantRepoPolicyRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AuthroleTenantRepoPolicyRequestMultiError(errors)
	}

	return nil
}

// AuthroleTenantRepoPolicyRequestMultiError is an error wrapping multiple
// validation errors returned by AuthroleTenantRepoPolicyRequest.ValidateAll()
// if the designated constraints aren't met.
type AuthroleTenantRepoPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthroleTenantRepoPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthroleTenantRepoPolicyRequestMultiError) AllErrors() []error { return m }

// AuthroleTenantRepoPolicyRequestValidationError is the validation error
// returned by AuthroleTenantRepoPolicyRequest.Validate if the designated
// constraints aren't met.
type AuthroleTenantRepoPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthroleTenantRepoPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthroleTenantRepoPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthroleTenantRepoPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthroleTenantRepoPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthroleTenantRepoPolicyRequestValidationError) ErrorName() string {
	return "AuthroleTenantRepoPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AuthroleTenantRepoPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthroleTenantRepoPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthroleTenantRepoPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthroleTenantRepoPolicyRequestValidationError{}

// Validate checks the field values on GrantAuthrolePolicyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GrantAuthrolePolicyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GrantAuthrolePolicyReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GrantAuthrolePolicyReplyMultiError, or nil if none found.
func (m *GrantAuthrolePolicyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GrantAuthrolePolicyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return GrantAuthrolePolicyReplyMultiError(errors)
	}

	return nil
}

// GrantAuthrolePolicyReplyMultiError is an error wrapping multiple validation
// errors returned by GrantAuthrolePolicyReply.ValidateAll() if the designated
// constraints aren't met.
type GrantAuthrolePolicyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GrantAuthrolePolicyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GrantAuthrolePolicyReplyMultiError) AllErrors() []error { return m }

// GrantAuthrolePolicyReplyValidationError is the validation error returned by
// GrantAuthrolePolicyReply.Validate if the designated constraints aren't met.
type GrantAuthrolePolicyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GrantAuthrolePolicyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GrantAuthrolePolicyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GrantAuthrolePolicyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GrantAuthrolePolicyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GrantAuthrolePolicyReplyValidationError) ErrorName() string {
	return "GrantAuthrolePolicyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GrantAuthrolePolicyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGrantAuthrolePolicyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GrantAuthrolePolicyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GrantAuthrolePolicyReplyValidationError{}

// Validate checks the field values on RevokeAuthrolePolicyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RevokeAuthrolePolicyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RevokeAuthrolePolicyReply with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RevokeAuthrolePolicyReplyMultiError, or nil if none found.
func (m *RevokeAuthrolePolicyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *RevokeAuthrolePolicyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Msg

	if len(errors) > 0 {
		return RevokeAuthrolePolicyReplyMultiError(errors)
	}

	return nil
}

// RevokeAuthrolePolicyReplyMultiError is an error wrapping multiple validation
// errors returned by RevokeAuthrolePolicyReply.ValidateAll() if the
// designated constraints aren't met.
type RevokeAuthrolePolicyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RevokeAuthrolePolicyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RevokeAuthrolePolicyReplyMultiError) AllErrors() []error { return m }

// RevokeAuthrolePolicyReplyValidationError is the validation error returned by
// RevokeAuthrolePolicyReply.Validate if the designated constraints aren't met.
type RevokeAuthrolePolicyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RevokeAuthrolePolicyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RevokeAuthrolePolicyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RevokeAuthrolePolicyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RevokeAuthrolePolicyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RevokeAuthrolePolicyReplyValidationError) ErrorName() string {
	return "RevokeAuthrolePolicyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e RevokeAuthrolePolicyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRevokeAuthrolePolicyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RevokeAuthrolePolicyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RevokeAuthrolePolicyReplyValidationError{}
